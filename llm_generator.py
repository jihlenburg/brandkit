#!/usr/bin/env python3
"""
LLM-Powered Brand Name Generator
=================================
Uses Claude API for creative, semantically-aware brand name generation.

Enhanced with linguistic features:
- Phonaesthetics (sound symbolism) guidance
- Brand archetype support (power, elegance, speed, etc.)
- Industry-specific generation
- Cultural influence specification
- Cross-linguistic hazard checking
- Memorability scoring

Advantages over rule-based/Markov approaches:
- Understands semantic nuances and connotations
- Can create wordplay and clever combinations
- Considers cultural context for DE/EN markets
- Can explain the reasoning behind names
"""

import os
import json
import http.client
import ssl
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from pathlib import Path


@dataclass
class LLMGeneratedName:
    """A name generated by the LLM with explanation and analysis"""
    name: str
    explanation: str
    associations: list
    score_estimate: float  # LLM's own estimate of name quality
    # Enhanced fields from post-processing
    memorability_score: float = 0.0
    archetype_fit: float = 0.0
    hazards: List[Dict] = field(default_factory=list)
    culture_hints: List[str] = field(default_factory=list)


@dataclass
class LLMGenerationResult:
    """Result of LLM generation"""
    names: list  # List of LLMGeneratedName
    error: Optional[str] = None
    filtered_count: int = 0  # Names filtered due to hazards


# =============================================================================
# Archetype Definitions (for prompt enhancement)
# =============================================================================

ARCHETYPE_GUIDANCE = {
    'power': {
        'description': 'Strong, dominant, authoritative',
        'sounds': 'strong plosives (k, t, p, b, d, g), short vowels, hard endings',
        'examples': 'Kraft, Titan, Apex, Vortex',
        'avoid': 'soft sounds, diminutive endings',
    },
    'elegance': {
        'description': 'Refined, sophisticated, luxurious',
        'sounds': 'flowing consonants (l, s, f, v), open vowels (a, o), soft endings',
        'examples': 'Lumina, Serena, Velara, Aura',
        'avoid': 'harsh clusters, abrupt endings',
    },
    'speed': {
        'description': 'Fast, dynamic, energetic',
        'sounds': 'sharp consonants (z, x, v), quick rhythm, short syllables',
        'examples': 'Vex, Zephyr, Flux, Swift',
        'avoid': 'heavy sounds, slow rhythms',
    },
    'nature': {
        'description': 'Organic, earthy, sustainable',
        'sounds': 'soft consonants (l, m, n), earthy vowels, flowing sounds',
        'examples': 'Terra, Arbor, Flora, Verde',
        'avoid': 'mechanical sounds, harsh consonants',
    },
    'tech': {
        'description': 'Modern, innovative, precise',
        'sounds': 'crisp consonants (x, k, z), clean vowels, tech suffixes (-ix, -ex, -on)',
        'examples': 'Nexus, Vertex, Syntex, Quantix',
        'avoid': 'dated sounds, overly soft endings',
    },
    'trust': {
        'description': 'Reliable, stable, dependable',
        'sounds': 'solid consonants (b, d, m), stable rhythm, grounded endings',
        'examples': 'Solidus, Fidelis, Constans, Verum',
        'avoid': 'flighty sounds, unstable patterns',
    },
    'innovation': {
        'description': 'Creative, forward-thinking, unique',
        'sounds': 'unusual combinations, distinctive patterns, memorable hooks',
        'examples': 'Quiron, Novix, Ideara, Zenith',
        'avoid': 'conventional patterns, generic sounds',
    },
}

INDUSTRY_GUIDANCE = {
    'tech': {
        'description': 'Software, hardware, SaaS, AI',
        'style': 'Modern, clean, innovative',
        'cultures': ['Greek', 'Japanese', 'Latin', 'Celestial'],
        'suffixes': '-ix, -ex, -io, -ly, -fy',
    },
    'automotive': {
        'description': 'Vehicles, parts, mobility',
        'style': 'Powerful, dynamic, reliable',
        'cultures': ['Turkic', 'Nordic', 'Latin'],
        'suffixes': '-a, -o, -on, -us',
    },
    'pharma': {
        'description': 'Pharmaceuticals, biotech, medical',
        'style': 'Scientific, trustworthy, precise',
        'cultures': ['Greek', 'Latin'],
        'suffixes': '-in, -ol, -ex, -ia',
    },
    'luxury': {
        'description': 'Premium goods, fashion, jewelry',
        'style': 'Elegant, refined, exclusive',
        'cultures': ['Latin', 'French', 'Italian'],
        'suffixes': '-a, -elle, -ini, -or',
    },
    'wellness': {
        'description': 'Health, yoga, meditation, supplements',
        'style': 'Calming, natural, spiritual',
        'cultures': ['Japanese', 'Celtic', 'Latin'],
        'suffixes': '-a, -ana, -ya, -i',
    },
    'energy': {
        'description': 'Power, solar, batteries, electrical',
        'style': 'Powerful, reliable, innovative',
        'cultures': ['Greek', 'Nordic', 'Latin', 'Celestial'],
        'suffixes': '-on, -ex, -ix, -or',
    },
    'outdoor': {
        'description': 'Camping, hiking, adventure gear',
        'style': 'Rugged, natural, adventurous',
        'cultures': ['Nordic', 'Celtic'],
        'suffixes': '-er, -or, -a, -en',
    },
    'gaming': {
        'description': 'Video games, esports, gaming gear',
        'style': 'Dynamic, exciting, memorable',
        'cultures': ['Japanese', 'Greek', 'Nordic'],
        'suffixes': '-ix, -ex, -a, -o',
    },
    'food_beverage': {
        'description': 'Food products, drinks, restaurants',
        'style': 'Appetizing, warm, memorable',
        'cultures': ['Latin', 'Celtic', 'Nordic'],
        'suffixes': '-a, -o, -y, -ia',
    },
    'finance': {
        'description': 'Banking, investment, fintech',
        'style': 'Trustworthy, stable, professional',
        'cultures': ['Latin', 'Greek'],
        'suffixes': '-us, -is, -ex, -or',
    },
}

CULTURE_GUIDANCE = {
    'greek': 'Greek mythology and classical roots (gods, titans, concepts like dynamis, logos)',
    'latin': 'Classical Latin and Romance languages (elegant, scientific, premium feel)',
    'nordic': 'Norse mythology and Scandinavian nature (strong, rugged, natural)',
    'japanese': 'Japanese CV patterns, minimalist (clean, tech-forward, zen aesthetic)',
    'celtic': 'Irish, Welsh, Scottish roots (mystical, nature-based, heritage feel)',
    'celestial': 'Space and astronomy roots (stars, planets, cosmic phenomena, futuristic)',
    'turkic': 'Turkic language patterns with vowel harmony (automotive, dynamic)',
}


class LLMGenerator:
    """
    Generates brand names using Claude API.

    Enhanced with linguistic analysis features:
    - Phonaesthetics guidance
    - Brand archetype support
    - Industry-specific generation
    - Cultural influence specification
    - Automatic hazard checking
    - Memorability scoring

    Usage:
        generator = LLMGenerator()
        result = generator.generate(
            count=10,
            context="DC/DC converters for camping vehicles",
            archetype="power",
            industry="energy",
            cultures=["greek", "nordic"],
            check_hazards=True
        )
    """

    API_HOST = "api.anthropic.com"
    API_VERSION = "2023-06-01"
    MODEL = "claude-sonnet-4-20250514"

    def __init__(self, api_key: str = None):
        """
        Initialize the LLM generator.

        Args:
            api_key: Anthropic API key (or set ANTHROPIC_API_KEY env var)
        """
        self.api_key = api_key or os.environ.get('ANTHROPIC_API_KEY')

        # Lazy-load analysis components
        self._hazard_checker = None
        self._memorability_scorer = None
        self._phonaesthetics = None

    def _get_hazard_checker(self):
        """Lazy-load hazard checker."""
        if self._hazard_checker is None:
            try:
                from brandkit.generators.base_generator import HazardChecker
                self._hazard_checker = HazardChecker()
            except ImportError:
                pass
        return self._hazard_checker

    def _get_memorability_scorer(self):
        """Lazy-load memorability scorer."""
        if self._memorability_scorer is None:
            try:
                from brandkit.generators.base_generator import MemorabilityScorer
                self._memorability_scorer = MemorabilityScorer()
            except ImportError:
                pass
        return self._memorability_scorer

    def _get_phonaesthetics(self):
        """Lazy-load phonaesthetics engine."""
        if self._phonaesthetics is None:
            try:
                from brandkit.generators.base_generator import PhonaestheticsEngine
                self._phonaesthetics = PhonaestheticsEngine()
            except ImportError:
                pass
        return self._phonaesthetics

    @property
    def has_api_access(self) -> bool:
        """Check if API key is available"""
        return bool(self.api_key)

    def _build_system_prompt(self, archetype: str = None, industry: str = None,
                              cultures: List[str] = None) -> str:
        """Build enhanced system prompt with linguistic guidance."""

        prompt = """You are an expert brand naming consultant specializing in creating memorable, phonetically pleasing brand names for the German and English markets.

Your expertise includes:
- Phonetics and phonotactics (what sounds good in both languages)
- Morphology (meaningful word parts from Latin, Greek, English, German)
- Brand psychology (what makes names memorable and trustworthy)
- Sound symbolism (phonaesthetics - how sounds convey meaning)
- Cross-cultural linguistics (avoiding negative connotations internationally)

## Core Guidelines

1. LENGTH: 4-7 characters ideal, max 9
2. SYLLABLES: 2 syllables optimal, 3 acceptable
3. SOUNDS: Balance consonants and vowels for flow
4. AVOID: Difficult consonant clusters, negative connotations in DE or EN

## Sound Symbolism (Phonaesthetics)

Use these sound associations:
- gl- prefix: light, glow, brightness (glow, gleam, glint)
- fl- prefix: flow, fluidity, lightness (flow, float, flutter)
- str- prefix: strength, structure (strong, straight, stride)
- -ck ending: quick, sharp, decisive
- -ng ending: lasting, ongoing, strong

Vowel associations:
- 'i', 'e': small, quick, bright, precise
- 'a', 'o': large, open, bold, solid
- 'u': deep, dark, powerful

Consonant feel:
- Plosives (k, t, p, b, d, g): strong, decisive, powerful
- Fricatives (s, f, v, z): smooth, flowing, elegant
- Nasals (m, n): warm, soft, approachable
- Liquids (l, r): flowing, elegant, dynamic
"""

        # Add archetype guidance
        if archetype and archetype.lower() in ARCHETYPE_GUIDANCE:
            arch = ARCHETYPE_GUIDANCE[archetype.lower()]
            prompt += f"""
## Brand Archetype: {archetype.upper()}

Target feel: {arch['description']}
Preferred sounds: {arch['sounds']}
Reference examples: {arch['examples']}
Avoid: {arch['avoid']}
"""

        # Add industry guidance
        if industry and industry.lower() in INDUSTRY_GUIDANCE:
            ind = INDUSTRY_GUIDANCE[industry.lower()]
            prompt += f"""
## Industry Context: {industry.upper()}

Industry: {ind['description']}
Style: {ind['style']}
Recommended cultural influences: {', '.join(ind['cultures'])}
Common effective suffixes: {ind['suffixes']}
"""

        # Add cultural guidance
        if cultures:
            prompt += "\n## Cultural Influences\n\nDraw inspiration from:\n"
            for culture in cultures:
                if culture.lower() in CULTURE_GUIDANCE:
                    prompt += f"- {culture.upper()}: {CULTURE_GUIDANCE[culture.lower()]}\n"

        prompt += """
## Critical Requirements

Names MUST:
- Be easy to pronounce in both German AND English
- Have no negative connotations in either language
- Sound professional and trustworthy
- Be memorable and distinctive
- Avoid sounds that could be vulgar when spoken (e.g., avoid patterns that sound like profanity)

IMPORTANT: Avoid names that could sound embarrassing in any major language. Check that the name doesn't resemble words for bodily functions, profanity, or negative concepts in German, French, Spanish, Italian, or other major languages.
"""
        return prompt

    def _call_api(self, messages: list, system_prompt: str, max_tokens: int = 2000) -> dict:
        """Make API call to Claude."""
        if not self.has_api_access:
            return {'error': 'No API key available'}

        try:
            conn = http.client.HTTPSConnection(
                self.API_HOST,
                context=ssl.create_default_context()
            )

            headers = {
                'Content-Type': 'application/json',
                'x-api-key': self.api_key,
                'anthropic-version': self.API_VERSION
            }

            payload = json.dumps({
                'model': self.MODEL,
                'max_tokens': max_tokens,
                'system': system_prompt,
                'messages': messages
            })

            conn.request('POST', '/v1/messages', payload, headers)
            response = conn.getresponse()

            if response.status == 200:
                return json.loads(response.read().decode())
            else:
                error_body = response.read().decode()
                return {'error': f'API error {response.status}: {error_body[:200]}'}

        except Exception as e:
            return {'error': f'Request failed: {e}'}

    def generate(self,
                 count: int = 10,
                 context: str = "DC/DC converters and power electronics for camping and recreational vehicles",
                 style: str = "modern, technical but approachable",
                 archetype: str = None,
                 industry: str = None,
                 cultures: List[str] = None,
                 check_hazards: bool = True,
                 markets: List[str] = None,
                 constraints: list = None,
                 existing_names: list = None) -> LLMGenerationResult:
        """
        Generate brand names using Claude.

        Args:
            count: Number of names to generate
            context: Product/market context
            style: Desired brand style/tone
            archetype: Brand archetype (power, elegance, speed, nature, tech, trust, innovation)
            industry: Target industry (tech, pharma, wellness, energy, etc.)
            cultures: Cultural influences to draw from (greek, latin, japanese, etc.)
            check_hazards: Whether to filter names with cross-linguistic hazards
            markets: Target markets for hazard checking (e.g., ['german', 'french'])
            constraints: Additional constraints (e.g., "must start with V")
            existing_names: Names to avoid similarity with

        Returns:
            LLMGenerationResult with generated names
        """
        if not self.has_api_access:
            return LLMGenerationResult(
                names=[],
                error="No Anthropic API key. Set ANTHROPIC_API_KEY env var."
            )

        # Build enhanced system prompt
        system_prompt = self._build_system_prompt(archetype, industry, cultures)

        # Build the user prompt
        prompt = f"""Generate {count + 5} unique brand names for the following context:

PRODUCT/MARKET: {context}

DESIRED STYLE: {style}

TARGET MARKETS: Germany and English-speaking countries (names must work in both)

"""
        if archetype:
            prompt += f"BRAND ARCHETYPE: {archetype} - names should embody this personality\n\n"

        if industry:
            prompt += f"INDUSTRY: {industry}\n\n"

        if cultures:
            prompt += f"CULTURAL INFLUENCES: Draw inspiration from {', '.join(cultures)} linguistic traditions\n\n"

        if constraints:
            prompt += f"CONSTRAINTS:\n" + "\n".join(f"- {c}" for c in constraints) + "\n\n"

        if existing_names:
            prompt += f"AVOID SIMILARITY TO: {', '.join(existing_names[:20])}\n\n"

        prompt += """For each name, provide:
1. The name itself
2. A brief explanation (1-2 sentences) of why it works
3. Key associations/connotations
4. Your confidence score (0.0-1.0) for this name
5. Any cultural influences used

Format your response as JSON:
{
  "names": [
    {
      "name": "Voltara",
      "explanation": "Combines 'volt' (electricity) with feminine ending '-ara' suggesting flow and elegance",
      "associations": ["voltage", "power", "flow", "elegance"],
      "score": 0.85,
      "culture_hints": ["Latin"]
    }
  ]
}

Generate the names now. Be creative but practical. Ensure each name sounds good when spoken aloud in both German and English."""

        # Make API call
        response = self._call_api([{'role': 'user', 'content': prompt}], system_prompt)

        if 'error' in response:
            return LLMGenerationResult(names=[], error=response['error'])

        # Parse response
        try:
            content = response.get('content', [{}])[0].get('text', '')

            # Extract JSON from response (might be wrapped in markdown)
            json_start = content.find('{')
            json_end = content.rfind('}') + 1
            if json_start >= 0 and json_end > json_start:
                json_str = content[json_start:json_end]
                data = json.loads(json_str)

                names = []
                filtered_count = 0

                for item in data.get('names', []):
                    name_str = item.get('name', '')
                    if not name_str:
                        continue

                    # Check hazards if enabled
                    hazards = []
                    if check_hazards:
                        checker = self._get_hazard_checker()
                        if checker:
                            result = checker.check(name_str, markets)
                            if result.severity in ['high', 'critical']:
                                filtered_count += 1
                                continue  # Skip hazardous names
                            hazards = result.issues

                    # Calculate memorability score
                    memorability_score = item.get('score', 0.5)
                    archetype_fit = 0.5
                    scorer = self._get_memorability_scorer()
                    if scorer:
                        scores = scorer.score(name_str, archetype, industry)
                        memorability_score = scores.get('overall', memorability_score)

                    # Calculate archetype fit
                    if archetype:
                        phonaesthetics = self._get_phonaesthetics()
                        if phonaesthetics:
                            archetype_fit = phonaesthetics.score_for_archetype(name_str, archetype)

                    names.append(LLMGeneratedName(
                        name=name_str,
                        explanation=item.get('explanation', ''),
                        associations=item.get('associations', []),
                        score_estimate=float(item.get('score', 0.5)),
                        memorability_score=memorability_score,
                        archetype_fit=archetype_fit,
                        hazards=hazards,
                        culture_hints=item.get('culture_hints', [])
                    ))

                # Sort by memorability score and return requested count
                names.sort(key=lambda n: n.memorability_score, reverse=True)

                return LLMGenerationResult(
                    names=names[:count],
                    filtered_count=filtered_count
                )

        except (json.JSONDecodeError, KeyError, IndexError) as e:
            return LLMGenerationResult(
                names=[],
                error=f"Failed to parse response: {e}"
            )

        return LLMGenerationResult(names=[], error="Unknown error")

    def refine(self,
               names: list[str],
               feedback: str,
               context: str = None,
               archetype: str = None) -> LLMGenerationResult:
        """
        Refine existing names based on feedback.

        Args:
            names: List of names to refine
            feedback: What to improve/change
            context: Optional context reminder
            archetype: Brand archetype for guidance

        Returns:
            LLMGenerationResult with refined names
        """
        if not self.has_api_access:
            return LLMGenerationResult(
                names=[],
                error="No Anthropic API key."
            )

        system_prompt = self._build_system_prompt(archetype)

        prompt = f"""I have these brand name candidates:
{', '.join(names)}

Feedback/Request: {feedback}

"""
        if context:
            prompt += f"Context: {context}\n\n"

        prompt += """Based on this feedback, provide improved versions or alternatives.

Format as JSON:
{
  "names": [
    {
      "name": "ImprovedName",
      "explanation": "Why this addresses the feedback",
      "associations": ["key", "associations"],
      "score": 0.8,
      "culture_hints": []
    }
  ]
}"""

        response = self._call_api([{'role': 'user', 'content': prompt}], system_prompt)

        if 'error' in response:
            return LLMGenerationResult(names=[], error=response['error'])

        try:
            content = response.get('content', [{}])[0].get('text', '')
            json_start = content.find('{')
            json_end = content.rfind('}') + 1
            if json_start >= 0 and json_end > json_start:
                data = json.loads(content[json_start:json_end])

                names = []
                for item in data.get('names', []):
                    names.append(LLMGeneratedName(
                        name=item.get('name', ''),
                        explanation=item.get('explanation', ''),
                        associations=item.get('associations', []),
                        score_estimate=float(item.get('score', 0.5)),
                        culture_hints=item.get('culture_hints', [])
                    ))

                return LLMGenerationResult(names=names)

        except Exception as e:
            return LLMGenerationResult(names=[], error=f"Parse error: {e}")

        return LLMGenerationResult(names=[], error="Unknown error")

    def evaluate(self, name: str, context: str = None, archetype: str = None) -> dict:
        """
        Get detailed evaluation of a single name.

        Args:
            name: Brand name to evaluate
            context: Product/market context
            archetype: Brand archetype for fit assessment

        Returns:
            Dictionary with detailed evaluation
        """
        if not self.has_api_access:
            return {'error': 'No API key'}

        system_prompt = self._build_system_prompt(archetype)

        prompt = f"""Evaluate this brand name: "{name}"

"""
        if context:
            prompt += f"Context: {context}\n\n"

        if archetype:
            prompt += f"Target archetype: {archetype}\n\n"

        prompt += """Provide a detailed analysis:

1. PRONUNCIATION
   - How easy to say in German?
   - How easy to say in English?
   - Any pronunciation pitfalls?

2. MEMORABILITY
   - Is it distinctive?
   - Easy to remember?
   - Easy to spell?

3. PHONAESTHETICS (Sound Symbolism)
   - What feelings does the sound evoke?
   - Does it match the intended brand personality?
   - Onset/ending analysis

4. CONNOTATIONS
   - What does it evoke?
   - Any negative associations in German?
   - Any negative associations in English?
   - Any risky sound-alikes in other languages?

5. BRAND FIT
   - Does it sound professional?
   - Does it sound modern?
   - Would it work for the target context?

6. CROSS-LINGUISTIC SAFETY
   - Any risks in French, Spanish, Italian, Dutch?
   - Does it sound like anything inappropriate?

7. OVERALL SCORE (0-10)

Format as JSON:
{
  "pronunciation": {"german": 8, "english": 9, "notes": "..."},
  "memorability": {"distinctive": 7, "memorable": 8, "spellable": 9},
  "phonaesthetics": {"feel": ["..."], "archetype_fit": 7, "notes": "..."},
  "connotations": {"positive": ["...", "..."], "negative": [], "notes": "..."},
  "brand_fit": {"professional": 8, "modern": 9, "context_suitable": 8},
  "cross_linguistic": {"safe": true, "risks": [], "notes": "..."},
  "overall_score": 8.2,
  "summary": "..."
}"""

        response = self._call_api([{'role': 'user', 'content': prompt}], system_prompt)

        if 'error' in response:
            return {'error': response['error']}

        try:
            content = response.get('content', [{}])[0].get('text', '')
            json_start = content.find('{')
            json_end = content.rfind('}') + 1
            if json_start >= 0 and json_end > json_start:
                result = json.loads(content[json_start:json_end])

                # Add our own analysis
                checker = self._get_hazard_checker()
                if checker:
                    hazard_result = checker.check(name)
                    result['hazard_check'] = {
                        'is_safe': hazard_result.is_safe,
                        'severity': hazard_result.severity,
                        'issues': hazard_result.issues
                    }

                scorer = self._get_memorability_scorer()
                if scorer:
                    scores = scorer.score(name, archetype)
                    result['memorability_analysis'] = scores

                return result
        except Exception as e:
            return {'error': f'Parse error: {e}'}

        return {'error': 'Unknown error'}

    def generate_for_archetype(self, archetype: str, count: int = 10,
                                context: str = None, **kwargs) -> LLMGenerationResult:
        """
        Convenience method to generate names for a specific archetype.

        Args:
            archetype: Brand archetype (power, elegance, speed, nature, tech, trust, innovation)
            count: Number of names to generate
            context: Product context
            **kwargs: Additional arguments passed to generate()

        Returns:
            LLMGenerationResult with archetype-optimized names
        """
        if archetype.lower() not in ARCHETYPE_GUIDANCE:
            return LLMGenerationResult(
                names=[],
                error=f"Unknown archetype: {archetype}. Available: {list(ARCHETYPE_GUIDANCE.keys())}"
            )

        arch = ARCHETYPE_GUIDANCE[archetype.lower()]
        style = f"{arch['description']}, with {arch['sounds']}"

        return self.generate(
            count=count,
            context=context or "brand products",
            style=style,
            archetype=archetype,
            **kwargs
        )

    def generate_for_industry(self, industry: str, count: int = 10,
                               context: str = None, **kwargs) -> LLMGenerationResult:
        """
        Convenience method to generate names for a specific industry.

        Args:
            industry: Target industry (tech, pharma, wellness, etc.)
            count: Number of names to generate
            context: Additional product context
            **kwargs: Additional arguments passed to generate()

        Returns:
            LLMGenerationResult with industry-optimized names
        """
        if industry.lower() not in INDUSTRY_GUIDANCE:
            return LLMGenerationResult(
                names=[],
                error=f"Unknown industry: {industry}. Available: {list(INDUSTRY_GUIDANCE.keys())}"
            )

        ind = INDUSTRY_GUIDANCE[industry.lower()]
        full_context = f"{ind['description']}"
        if context:
            full_context += f" - specifically: {context}"

        # Map industry cultures to our culture keys
        culture_map = {
            'Greek': 'greek', 'Latin': 'latin', 'Nordic': 'nordic',
            'Japanese': 'japanese', 'Celtic': 'celtic', 'Celestial': 'celestial',
            'Turkic': 'turkic', 'French': 'latin', 'Italian': 'latin'
        }
        cultures = [culture_map.get(c, c.lower()) for c in ind['cultures']]

        return self.generate(
            count=count,
            context=full_context,
            style=ind['style'],
            industry=industry,
            cultures=cultures,
            **kwargs
        )


# Singleton
_default_generator = None

def get_llm_generator() -> LLMGenerator:
    """Get default generator instance"""
    global _default_generator
    if _default_generator is None:
        _default_generator = LLMGenerator()
    return _default_generator


if __name__ == '__main__':
    import argparse

    # Load .env
    env_path = Path(__file__).parent / '.env'
    if env_path.exists():
        for line in env_path.read_text().splitlines():
            if '=' in line and not line.startswith('#'):
                key, value = line.split('=', 1)
                os.environ.setdefault(key.strip(), value.strip())

    parser = argparse.ArgumentParser(description='Generate brand names with Claude')
    parser.add_argument('--count', '-n', type=int, default=10, help='Number of names')
    parser.add_argument('--context', '-c', type=str,
                        default='DC/DC converters for camping vehicles',
                        help='Product context')
    parser.add_argument('--style', '-s', type=str,
                        default='modern, technical but approachable',
                        help='Brand style')
    parser.add_argument('--archetype', '-a', type=str,
                        choices=list(ARCHETYPE_GUIDANCE.keys()),
                        help='Brand archetype')
    parser.add_argument('--industry', '-i', type=str,
                        choices=list(INDUSTRY_GUIDANCE.keys()),
                        help='Target industry')
    parser.add_argument('--cultures', type=str,
                        help='Cultural influences (comma-separated: greek,latin,japanese)')
    parser.add_argument('--evaluate', '-e', type=str,
                        help='Evaluate a single name instead of generating')
    parser.add_argument('--no-hazard-check', action='store_true',
                        help='Skip hazard checking')

    args = parser.parse_args()

    generator = LLMGenerator()

    if not generator.has_api_access:
        print("No ANTHROPIC_API_KEY found. Please set the environment variable.")
        exit(1)

    if args.evaluate:
        print(f"Evaluating: {args.evaluate}\n")
        result = generator.evaluate(args.evaluate, args.context, args.archetype)
        print(json.dumps(result, indent=2, ensure_ascii=False))
    else:
        print(f"Generating {args.count} names...")
        print(f"Context: {args.context}")
        print(f"Style: {args.style}")
        if args.archetype:
            print(f"Archetype: {args.archetype}")
        if args.industry:
            print(f"Industry: {args.industry}")
        if args.cultures:
            print(f"Cultures: {args.cultures}")
        print()

        cultures = args.cultures.split(',') if args.cultures else None

        result = generator.generate(
            count=args.count,
            context=args.context,
            style=args.style,
            archetype=args.archetype,
            industry=args.industry,
            cultures=cultures,
            check_hazards=not args.no_hazard_check
        )

        if result.error:
            print(f"Error: {result.error}")
        else:
            if result.filtered_count > 0:
                print(f"(Filtered {result.filtered_count} names due to hazards)\n")

            print(f"Generated {len(result.names)} names:\n")
            for i, name in enumerate(result.names, 1):
                print(f"{i:2}. {name.name:<15} [LLM: {name.score_estimate:.2f}] [Mem: {name.memorability_score:.2f}]")
                print(f"    {name.explanation}")
                print(f"    Associations: {', '.join(name.associations)}")
                if name.culture_hints:
                    print(f"    Cultures: {', '.join(name.culture_hints)}")
                if name.hazards:
                    print(f"    Hazards: {len(name.hazards)} warnings")
                print()
